## Пояснение: как устроены thunk'ы, использование Redux и axios, применение сгенерированного Swagger-клиента

Этот документ кратко описывает, как в проекте устроены асинхронные экшены (thunk'и) с помощью Redux Toolkit, как можно интегрировать сгенерированный Swagger-клиент (axios) и даёт примеры кода для рефакторинга существующих thunk'ов.

---

## 1. Краткая картина текущей реализации

- Проект использует Redux Toolkit (`configureStore`, `createSlice`, `createAsyncThunk`).
- В слайсах (`src/store/slices/authSlice.ts`, `cartSlice.ts`, `ordersSlice.ts`) thunks написаны через `createAsyncThunk` и используют `fetch` напрямую.
- Есть сгенерированный Swagger-клиент в `src/api/Api.ts` (класс `HttpClient` + `Api`), который использует axios и предоставляет типизированные методы для API.
- Паттерны в слайсах:
  - В thunk'ах проверяется токен (иногда через `localStorage`, иногда через `getState()`), выполняется fetch, в случае ошибок вызывается `rejectWithValue(...)`.
  - После мутаций часто делается `dispatch(...)` другого thunk'а для синхронизации (паттерн mutate -> refresh).
  - В состояниях хранится `loading: boolean` и `error: string | null`.

---

## 2. Почему стоит использовать сгенерированный Swagger-клиент (axios)

- Централизованная обработка авторизации (securityWorker / setSecurityData) — не нужно в каждом thunk читать `localStorage`.
- Интерсепторы axios удобны для логирования, единообразной обработки ошибок, retries и контроля контента.
- Типизация: сгенерированный клиент содержит интерфейсы и типы запросов/ответов.

---

## 3. Как создать и использовать Api (пример)

В `src/api/Api.ts` лежит сгенерированный код. Простой способ использовать его в thunk'ах — создать клиент и передать туда токен.

Пример: создать клиент прямо в thunk'е (быстро, но не оптимально):

```ts
import { HttpClient, Api } from "../api/Api";
import { createAsyncThunk } from "@reduxjs/toolkit";

export const addToCartAsync = createAsyncThunk<void, number, { rejectValue: string, state: any }>(
  "cart/addToCart",
  async (criterionId, { rejectWithValue, dispatch, getState }) => {
    const state = getState() as any;
    const token = state.auth?.token;
    if (!token) return rejectWithValue("Требуется авторизация");

    const http = new HttpClient();
    // В HttpClient есть setSecurityData — можно туда положить token
    http.setSecurityData(token);
    const api = new Api(http);

    try {
      // Сгенерированный метод: id.addToDraftCreate({ id })
      const res = await api.id.addToDraftCreate({ id: criterionId });
      // axios возвращает объект { data, status, ... }
      // при успешном ответе обновляем корзину
      await dispatch(fetchCartAsync());
    } catch (err: any) {
      return rejectWithValue(err?.message || "Ошибка добавления в заявку");
    }
  }
);
```

Пример с `securityWorker` (автоматическое добавление заголовка):

```ts
const http = new HttpClient({
  securityWorker: (securityData) => ({
    headers: {
      Authorization: `bearer ${securityData}`,
    },
  }),
});
http.setSecurityData(token);
const api = new Api(http);
// далее api.id.addToDraftCreate({ id })
```

---

## 4. Рекомендованный подход: единый singleton Api клиент

Создайте файл `src/api/client.ts` (один раз) и экспортируйте из него готовый `api` и `setToken`:

```ts
// src/api/client.ts
import { HttpClient, Api } from "./Api";

const http = new HttpClient({
  // можно задать базовые опции, interceptors и т.д.
});

export const api = new Api(http);

export const setToken = (token?: string | null) => {
  // setSecurityData хранит "securityData" внутри клиента
  http.setSecurityData(token ?? null);
};

export default api;
```

Использование в `authSlice` после успешного логина:

```ts
import { setToken } from "../../api/client";

// после успешного loginAsync.fulfilled
setToken(action.payload.access_token);
```

А в thunk'ах просто используйте импортированный `api`:

```ts
import { api } from "../../api/client";

await api.id.addToDraftCreate({ id: criterionId });
```

Такой подход решает проблему разбросанных обращений к `localStorage` и дублирования логики добавления заголовков.

---

## 5. Пример полного рефакторинга thunk'а (cartSlice)

Исходный паттерн (упрощённо):

```ts
export const addToCartAsync = createAsyncThunk<void, number, { rejectValue: string }>(
  "cart/addToCart",
  async (criterionId, { rejectWithValue, dispatch }) => {
    const token = localStorage.getItem("token");
    if (!token) return rejectWithValue("Требуется авторизация");

    const response = await fetch(`/api/criteria/${criterionId}/add-to-draft`, { method: 'POST', headers: { Authorization: `bearer ${token}` } });
    if (!response.ok) return rejectWithValue("Ошибка добавления в заявку");
    await dispatch(fetchCartAsync());
  }
);
```

Рефактоpинг с использованием `src/api/client.ts` (singleton):

```ts
import { createAsyncThunk } from "@reduxjs/toolkit";
import { api } from "../../api/client"; // наш singleton

export const addToCartAsync = createAsyncThunk<void, number, { rejectValue: string }>(
  "cart/addToCart",
  async (criterionId, { rejectWithValue, dispatch }) => {
    try {
      const res = await api.id.addToDraftCreate({ id: criterionId });
      // если нужно — можно проверять res.status или res.data
      await dispatch(fetchCartAsync());
    } catch (err: any) {
      // axios-ошибки имеют формат err.response?.data / err.message
      const message = err?.response?.data?.message || err?.message || "Ошибка добавления в заявку";
      return rejectWithValue(message);
    }
  }
);
```

Преимущества: единый клиент, упрощённая работа с заголовками и типами, меньше дублирования.

---

## 6. Практические советы и чек-лист миграции

1. Создайте `src/api/client.ts` (singleton) и используйте `http.setSecurityData(token)` при логине.
2. В `authSlice` при успешном login/register вызывайте `setToken(access_token)`.
3. В thunk'ах замените чтение `localStorage` на `getState()` (предпочтительно) или на `api` из `client.ts`.
4. Вынесите обработку ошибок в утилиту (например, `handleApiError(err): string`) чтобы вернуть человекочитаемое сообщение.
5. Покрывайте рефакторинг небольшими тестами (моки axios). Начните с одного слайса (например, `cart`) и затем перетащите остальное.

---

## 7. Заключение

- Текущая реализация правильная и рабочая — thunks через createAsyncThunk, понятная обработка состояний.
- Рефакторинг на сгенерированный Swagger-клиент даст централизованную авторизацию, безопасную и типобезопасную работу с API и облегчит поддержку.

---

Если хотите, могу:
- сделать PR c файлом `src/api/client.ts` и одним рефакторингом (например, `cartSlice.addToCartAsync`) чтобы показать рабочий пример, или
- сгенерировать unit-тесты для refactor'а.

Напишите, что предпочитаете дальше.